import{createPage as e,preparePageComponent as t,preparePageData as n,preparePagesComponents as a,preparePagesData as o,preparePagesRoutes as p}from"@vuepress/core";import{getDirname as r,path as i}from"@vuepress/utils";import{watch as s}from"chokidar";import{Logger as g,addViteSsrNoExternal as l}from"vuepress-shared";import{removeLeadingSlash as y}from"@vuepress/shared";const c=new g("vuepress-plugin-blog2"),u=(e,t)=>{const n={};return Object.keys({"/":{},...t.options.locales}).forEach((e=>{n[e]=[]})),t.pages.filter(e).forEach((e=>{n[e.pathLocale].push(e)})),n},f=(t,n,a,o=!1)=>{const{category:p=[],slugify:r=(e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase())}=n;return Promise.all(p.map((async({key:n,getter:p,sorter:i=(()=>-1),path:s="/:key/",layout:g="Layout",frontmatter:l=(()=>({})),itemPath:u="/:key/:name/",itemLayout:f="Layout",itemFrontmatter:h=(()=>({}))},m)=>{if("string"!=typeof n||!n)return c.error(`Invalid 'key' option ${n} in 'category[${m}]'`),null;if("function"!=typeof p)return c.error(`Invalid 'getter' option in 'category[${m}]', it should be a function!`),null;t.env.isDebug&&c.info(`Generating ${n} category.\n`);const d={},k=[],_="function"==typeof u?u:e=>(u||"").replace(/:key/g,r(n)).replace(/:name/g,r(e));for(const u in a){if(s){const a=`${u}${y(s.replace(/:key/g,r(n)))}`,p=await e(t,{path:a,frontmatter:{...l(u),blog:{type:"category",key:n},layout:g}}),i=t.pages.findIndex((({path:e})=>e===a));-1===i?t.pages.push(p):t.pages[i].key!==p.key&&(t.pages.splice(i,1,p),o&&c.warn(`Overiding existed path ${a}`)),k.push(p.key),d[u]={path:p.path,map:{}}}else d[u]={path:"",map:{}};const{map:m}=d[u],$={};for(const r of a[u]){const a=p(r);for(const p of a){if(!m[p]){const a=_(p);if(a){const r=`${u}${y(a)}`,i=await e(t,{path:`${u}${y(a)}`,frontmatter:{...h(p,u),blog:{type:"category",name:p,key:n},layout:f}}),s=t.pages.findIndex((({path:e})=>e===r));-1===s?t.pages.push(i):t.pages[s].key!==i.key&&(t.pages.splice(s,1,i),o&&c.warn(`Overiding existed path ${r}`)),k.push(i.key),m[p]={path:i.path,keys:[]}}else m[p]={path:"",keys:[]};$[p]=[]}$[p].push(r)}}for(const e in $)m[e].keys=$[e].sort(i).map((({key:e})=>e));if(t.env.isDebug){let e=`Route ${u} in ${n} cateogry:\n`;for(const t in m){const{path:n,keys:a}=m[t];e+=`name: ${t}; ${n?`path: ${n}; `:""}items: ${a.length}\n`}c.info(e)}}return{key:n,map:d,pageKeys:k}}))).then((async e=>{const n={},a=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:o})=>{n[e]=t,a.push(...o)})),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(n)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory) {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)\n  })\n}\n`),t.env.isDebug&&c.info("All categories generated."),a}))},h=(t,n,a,o=!1)=>{const{type:p=[],slugify:r=(e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase())}=n;return Promise.all(p.map((async({key:n,sorter:p=(()=>-1),filter:i=(()=>!0),path:s="/:key/",layout:g="Layout",frontmatter:l=(()=>({}))},u)=>{if("string"!=typeof n||!n)return c.error(`Invalid 'key' option ${n} in 'category[${u}]'`),null;const f={},h=[];t.env.isDebug&&c.info(`Generating ${n} type.\n`);for(const u in a){const m=a[u].filter(i).sort(p).map((({key:e})=>e));if(s){const a=`${u}${y(r(s.replace(/:key/g,n)))}`,p=await e(t,{path:a,frontmatter:{...l(u),blog:{type:"type",key:n},layout:g}}),i=t.pages.findIndex((({path:e})=>e===a));-1===i?t.pages.push(p):t.pages[i].key!==p.key&&(t.pages.splice(i,1,p),o&&c.warn(`Overiding existed path ${a}`)),h.push(p.key),f[u]={path:p.path,keys:m},t.env.isDebug&&c.info(`Route ${u} in ${n} type: path: ${p.path}; items: ${m.length}\n`)}else f[u]={path:"",keys:m},t.env.isDebug&&c.info(`Route ${u} in ${n} type: items: ${m.length}\n`)}return{key:n,map:f,pageKeys:h}}))).then((async e=>{const n={},a=[];return e.filter((e=>null!==e)).forEach((({key:e,map:t,pageKeys:o})=>{n[e]=t,a.push(...o)})),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(n)}\n\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept()\n  if (__VUE_HMR_RUNTIME__.updateBlogType) {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  }\n}\n\nif (import.meta.hot) {\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)\n  })\n}\n`),t.env.isDebug&&c.info("All types generated."),a}))},m=r(import.meta.url),d=e=>r=>{const{getInfo:g=(()=>({})),filter:y=(e=>Boolean(e.filePathRelative)&&!e.frontmatter.home),metaScope:d="_blog"}=e;let k=[];return r.env.isDebug&&c.info(`Options: ${e.toString()}`),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:d}),alias:{"vuepress-plugin-blog2/client":i.resolve(m,"../client/index.js")},extendsBundlerOptions:(e,t)=>{l({app:t,config:e},"vuepress-shared")},extendsPage:e=>{y(e)&&(e.routeMeta={...""===d?g(e):{[d]:g(e)},...e.routeMeta})},onInitialized:t=>{const n=u(y,t);return Promise.all([f(t,e,n,!0).then((e=>{k.push(...e)})),h(t,e,n,!0).then((e=>{k.push(...e)}))]).then((()=>{t.env.isDebug&&c.info("temp file generated")}))},onWatched:(r,i)=>{if(e.hotReload){const g=s("pages/**/*.js",{cwd:r.dir.temp(),ignoreInitial:!0}),l=()=>{const i=[],s=u(y,r);return Promise.all([f(r,e,s).then((e=>{i.push(...e)})),h(r,e,s).then((e=>{i.push(...e)}))]).then((async()=>{const e=k.filter((e=>!i.includes(e))),s=i.filter((e=>!k.includes(e)));s.length&&(r.env.isDebug&&c.info(`New pages detected: ${s.toString()}`),await Promise.all(s.map((async e=>{await t(r,r.pages.find((({key:t})=>t===e))),await n(r,r.pages.find((({key:t})=>t===e)))})))),e.length&&(r.env.isDebug&&c.info(`Removing following pages: ${e.toString()}`),e.forEach((e=>{r.pages.splice(r.pages.findIndex((({key:t})=>t===e)),1)}))),(e.length||s.length)&&(await a(r),await o(r),await p(r)),k=i,r.env.isDebug&&c.info("temp file updated")}))};g.on("add",(()=>{l()})),g.on("change",(()=>{l()})),g.on("unlink",(()=>{l()})),i.push(g)}}}};export{d as blogPlugin,d as default};
//# sourceMappingURL=index.js.map
